import { globby } from 'globby';
import path from 'path';
import fs from 'fs';
import { execSync } from 'child_process';

export const defaults = {
  head: `// ---------------------------------------------------------------------\n// ðŸ”’ AUTOGENERATED BY VENDORISM\n// Removing this comment will prevent it from being managed by it.\n// ---------------------------------------------------------------------\n\n`,
};

export async function removeVendors(config) {
  const files = await globby(`${config.target.path}/**/*`, config.target.removeVendors?.globby || { gitignore: true }); // adjust the pattern as needed

  for (const file of files) {
    const content = fs.readFileSync(file, 'utf8');
    if (content.startsWith(config.target.head)) {
      fs.unlinkSync(file);
      let currentDir = path.dirname(file);
      while (currentDir !== config.target.path) {
        if (fs.readdirSync(currentDir).length === 0) {
          fs.rmdirSync(currentDir);
          currentDir = path.dirname(currentDir);
        } else {
          break;
        }
      }
    }
  }
}

export async function createFiles(config) {
  // const files = await globby(path.join(config.source.path, config.source.).replace(/\\/g, "/"));

  // let overriden = [];
  // for (const sourceFile of files) {
  //   const relativePath = path.relative(path.join(sourceDir, component), sourceFile);
  //   const targetPath = path.join(targetDir, component, relativePath);

  //   // Check if target file already exists
  //   if (fs.existsSync(targetPath)) {
  //     continue; // skip copying
  //   }

  //   // Read source content, prepend header, and write to target
  //   const content = fs.readFileSync(sourceFile, 'utf8');
  //   const autoGeneratedContent = head + content;

  //   fs.mkdirSync(path.dirname(targetPath), { recursive: true });
  //   fs.writeFileSync(targetPath, autoGeneratedContent, 'utf8');

  //   overriden.push(targetPath.replace(/\\/g, "/"));
  // }
  // return overriden;
}


export const setTarget = async (config) => {
  if (config.target.hooks?.before) {
    await execSync(config.target.hooks.before);
  }

  if (!config.target.head) {
    config.target.head = defaults.head;
  }

  if (config.target?.path) {
    await removeVendors(config);
    // await download(config.target.url, config.target.path, { ...config.downloadConfig, extract: true });
  }

  if (config.target.hooks?.after) {
    await execSync(config.target.hooks.after);
  }
}
