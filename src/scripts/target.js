import { globby } from 'globby';
import path from 'path';
import fs from 'fs';
import { execSync } from 'child_process';
import dependencyTree from 'dependency-tree';
import { updateVsCodeReadOnlyFiles } from './update-vs-code-readonly-files.js';

export const defaults = {
  head: `// ---------------------------------------------------------------------\n// ðŸ”’ AUTOGENERATED BY VENDORISM\n// Removing this comment will prevent it from being managed by it.\n// ---------------------------------------------------------------------\n\n`,
};

function optimizePathForWindows(path) {
  return path.replace(/\\/g, "/");
}

export async function getDependencies(config) {
  const allDeps = new Set();

  // Get dependencies for each matched file
  for (const file of config.target.includes) {
    const list = await dependencyTree.toList({
      filename: config.source.path + '/' + file,
      directory: config.source.path,
      filter: path => path.indexOf('node_modules') === -1,
      noTypeDefinitions: true
    });

    list.forEach(dep => {
      // Convert the absolute path to a relative one
      const relativePath = path.relative(config.source.path, dep).replace('../', '');
      allDeps.add(relativePath);
    });
  }

  return Array.from(allDeps);
}

export async function removeVendors(config) {
  const files = await globby(`${config.target.path}/**/*`, config.target.removeVendors?.globby || { gitignore: true }); // adjust the pattern as needed

  let overriden = [];
  for (const file of files) {
    const content = fs.readFileSync(file, 'utf8');
    if (content.startsWith(config.target.head)) {
      // Remove file
      fs.unlinkSync(file);
      overriden.push(optimizePathForWindows(file));
      let currentDir = path.dirname(file);

      // Remove empty directories
      while (currentDir !== config.target.path) {
        if (fs.readdirSync(currentDir).length === 0) {
          fs.rmdirSync(currentDir);
          currentDir = path.dirname(currentDir);
        } else {
          break;
        }
      }
    }
  }

  return overriden;
}

export async function createVendors(config) {
  const files = !config.target.excludeDependencies
    ? await getDependencies(config)
    : config.target.includes;

  let overriden = [];
  for (const file of files) {
    const sourcePath = path.join(config.source.path, file);
    let targetPath = path.join(config.target.path, file);  // Initialize the variable to store the possibly transformed path

    // Read source content
    let content = fs.readFileSync(sourcePath, 'utf8');

    // Apply transforms if they exist
    if (config.target.transforms && Array.isArray(config.target.transforms)) {
      for (const transform of config.target.transforms) {
        const transformed = transform(targetPath, content); // Apply the transform function

        if (transformed && transformed.path && transformed.content) {
          // Update content and path with transformed values
          content = transformed.content;
          targetPath = transformed.path;
        }
      }
    }

    // Check if target file already exists
    if (fs.existsSync(targetPath)) {
      continue; // skip copying
    }

    const contentWithHead = config.target.head + content;

    fs.mkdirSync(path.dirname(targetPath), { recursive: true });
    fs.writeFileSync(targetPath, contentWithHead, 'utf8');

    overriden.push(optimizePathForWindows(targetPath));
  }
  return overriden;
}



export async function setTarget(config) {
  if (config.target.hooks?.before) {
    await execSync(config.target.hooks.before);
  }

  if (!config.target.head) {
    config.target.head = defaults.head;
  }

  if (config.target?.path) {
    const oldFiles = await removeVendors(config);
    const newFiles = await createVendors(config);
    if(config.target.lockFilesForVsCode) {
      await updateVsCodeReadOnlyFiles(oldFiles, newFiles, config.target.lockFilesForVsCode === true ? undefined : config.target.lockFilesForVsCode);
    }
  }

  if (config.target.hooks?.after) {
    await execSync(config.target.hooks.after);
  }
}
