import { globby } from 'globby';
import path from 'path';
import fs from 'fs';
import { execSync } from 'child_process';
import dependencyTree from 'dependency-tree';
import { updateVsCodeReadOnlyFiles, optimizePathForWindows } from './helpers.js';

/**
 * Default values for the target configuration.
 * 
 * @type {Object}
 * 
 * @property {string} head - The default head content to prepend to target files.
 */
export const defaults = {
  head: `
/**
 * ---------------------------------------------------------------------
 * ðŸ”’ AUTOGENERATED BY VENDORISM
 * Removing this comment will prevent it from being managed by it.
 * ---------------------------------------------------------------------
 */
`.trimStart(),
};

/**
 * Retrieves the dependencies of the specified included files based on the provided configuration.
 * 
 * This function performs the following steps:
 * - Iterates through the specified included files.
 * - Lists the dependencies of each file using `dependencyTree`.
 * - Filters out dependencies located within the node_modules directory.
 * - Converts the absolute path of each dependency to a relative one.
 * 
 * @async
 * @param {Array.<string>} includedFiles - The list of included files for which dependencies should be retrieved.
 * @param {Object} config - The configuration object.
 * @param {Object} config.source - The source configuration containing the path.
 * 
 * @returns {Promise<Array.<string>>} A promise that resolves with a list of dependencies.
 * 
 * @throws {Error} Throws an error if any step in the function fails.
 */
async function getDependenciesForIncludedFiles(includedFiles, config) {
  let allDeps = new Set();

  for (const file of includedFiles) {
    const list = await dependencyTree.toList({
      filename: path.join(config.source.path, file),
      directory: config.source.path,
      filter: path => path.indexOf('node_modules') === -1,
      noTypeDefinitions: true
    });

    list.forEach(dep => {
      // Convert the absolute path to a relative one
      const relativePath = optimizePathForWindows(path.relative(config.source.path, dep).replace('../', ''));
      allDeps.add(relativePath);
    });
  }

  return Array.from(allDeps);
}

/**
 * Removes vendor files based on the provided configuration.
 * 
 * This function performs the following steps:
 * - Retrieves files from the target path.
 * - Checks if the file content starts with the specified head.
 * - Removes files that have the specified head.
 * - Removes empty directories recursively.
 * 
 * @async
 * @param {Object} config - The configuration object.
 * @param {Object} config.target - The target configuration.
 * @param {string} config.target.path - The path for the target.
 * @param {string} config.target.head - The head content to match for removal.
 * @param {Object} [config.target.removeVendors] - Configuration for removing vendors.
 * @param {Object} [config.target.removeVendors.globby] - Globby configuration for file pattern matching.
 * 
 * @returns {Promise<Array.<string>>} A promise that resolves with a list of overridden paths.
 * 
 * @throws {Error} Throws an error if any step in the function fails.
 */
export async function removeVendors(config) {
  const files = await globby(`${config.target.path}/**/*`, config.target.removeVendors?.globby || { gitignore: true }); // adjust the pattern as needed

  let overriden = [];
  for (const file of files) {
    const content = fs.readFileSync(file, 'utf8');
    if (content.startsWith(config.target.head)) {
      // Remove file
      fs.unlinkSync(file);
      overriden.push(optimizePathForWindows(file));
      let currentDir = path.dirname(file);

      // Remove empty directories
      while (currentDir !== config.target.path) {
        if (fs.readdirSync(currentDir).length === 0) {
          fs.rmdirSync(currentDir);
          currentDir = path.dirname(currentDir);
        } else {
          break;
        }
      }
    }
  }

  return overriden;
}
/**
 * Creates vendors based on the provided configuration.
 * 
 * This function performs the following steps:
 * - Retrieves dependencies or includes files based on the excludeDependencies configuration.
 * - Reads content from the source path.
 * - Applies transforms to content and target path if they exist.
 * - Skips copying if target file already exists.
 * - Writes the file to the target path with the appropriate head.
 * 
 * @async
 * @param {Object} config - The configuration object.
 * @param {Object} config.source - The source configuration.
 * @param {Object} config.target - The target configuration.
 * @param {string} config.target.path - The path for the target.
 * @param {Array.<string>} config.target.includes - List of files or globs to include.
 * @param {Array.<function>} [config.target.transforms] - List of transform functions.
 * @param {boolean} [config.target.excludeDependencies=false] - Specifies whether to exclude dependencies.
 * @param {string} [config.target.head] - The head content to prepend to target files.
 * 
 * @returns {Promise<Array.<string>>} A promise that resolves with a list of overridden paths.
 * 
 * @throws {Error} Throws an error if any step in the function fails.
 */
export async function createVendors(config) {
  // Resolve files from the glob patterns in includes
  const includedFiles = await globby(config.target.includes, { cwd: config.source.path });

  // If excludeDependencies is false, get the dependencies for each file resolved from the globs.
  const dependencies = !config.target.excludeDependencies
    ? await getDependenciesForIncludedFiles(includedFiles, config)
    : [];

  // Merge included files and their dependencies
  const files = [...new Set([...includedFiles, ...dependencies])];

  let overriden = [];
  for (const file of files) {
    const sourcePath = path.join(config.source.path, file);
    let targetPath = path.join(config.target.path, file);  // Initialize the variable to store the possibly transformed path

    // Read source content
    let content = fs.readFileSync(sourcePath, 'utf8');

    // Apply transforms if they exist
    if (config.target.transforms && Array.isArray(config.target.transforms)) {
      for (const transform of config.target.transforms) {
        const transformed = transform(targetPath, content); // Apply the transform function

        if (transformed && transformed.path && transformed.content) {
          // Update content and path with transformed values
          content = transformed.content;
          targetPath = transformed.path;
        }
      }
    }

    // Check if target file already exists
    if (fs.existsSync(targetPath)) {
      continue; // skip copying
    }

    const contentWithHead = config.target.head + "\n" + content;

    fs.mkdirSync(path.dirname(targetPath), { recursive: true });
    fs.writeFileSync(targetPath, contentWithHead, 'utf8');

    overriden.push(optimizePathForWindows(targetPath));
  }
  return overriden;
}

/**
 * Sets up the target based on the provided configuration.
 * 
 * This function performs the following steps:
 * 1. Executes the before hook if provided.
 * 2. Assigns a default head to the target if none is provided.
 * 3. If a target path is provided, the function:
 *    - Removes vendors based on the configuration.
 *    - Creates new vendors, with potential path and content transformations.
 *    - If specified in the config, updates VS Code settings for read-only files.
 * 4. Executes the after hook if provided.
 * 
 * @async
 * @param {Object} config - The configuration object.
 * @param {Object} config.target - The target configuration.
 * @param {string} config.target.path - The path for the target.
 * @param {string} [config.target.head] - The head content to prepend to target files. Uses a default if not provided.
 * @param {boolean|string} [config.target.lockFilesForVsCode=false] - Specifies whether to lock files for VS Code. Can be a boolean or a custom path to VS Code settings.
 * @param {Object} [config.target.hooks] - Hooks to be executed before and after target processing.
 * @param {string} [config.target.hooks.before] - Command to be executed before target processing.
 * @param {string} [config.target.hooks.after] - Command to be executed after target processing.
 * @param {Function[]} [config.target.transforms] - An array of transform functions that can modify content and file paths. Each function takes in the current path and content and returns an object with potentially modified path and content.
 * 
 * @returns {Promise<{removedFiles: string[], newFiles: string[]}>}
 * 
 * @throws {Error} Throws an error if any step in the function fails.
 */
export async function setTarget(config) {
  const output = {};
  if (config.target.hooks?.before) {
    await execSync(config.target.hooks.before, { stdio: 'inherit' });
  }

  if (!config.target.head) {
    config.target.head = defaults.head;
  }

  if (config.target?.path) {
    output.removedFiles = await removeVendors(config);
    output.newFiles = await createVendors(config);
    if (config.target.lockFilesForVsCode) {
      await updateVsCodeReadOnlyFiles(output.newFiles, output.removedFiles, config.target.lockFilesForVsCode === true ? undefined : config.target.lockFilesForVsCode);
    }
  }

  if (config.target.hooks?.after) {
    await execSync(config.target.hooks.after, { stdio: 'inherit' });
  }
  return output;
}
