import { globby } from 'globby';
import path from 'path';
import fs from 'fs';
import { execSync } from 'child_process';
import dependencyTree from 'dependency-tree';
import { optimizePathForWindows } from './helpers.js';

/**
 * Default values for the set configuration.
 * 
 * @type {Object}
 * 
 * @property {string} head - The default head content to prepend to target files.
 */
export const defaults = {
  head: `
/**
 * ---------------------------------------------------------------------
 * ðŸ”’ AUTOGENERATED BY VENDORISM
 * Removing this comment will prevent it from being managed by it.
 * ---------------------------------------------------------------------
 */
`.trimStart(),
};

/**
 * Retrieves the dependencies of the specified included files based on the provided configuration.
 * 
 * @async
 * @param {Array.<string>} includedFiles - The list of included files for which dependencies should be retrieved.
 * @param {Object} config - The configuration object.
 * @param {Object} config.get - The source configuration containing the path.
 * 
 * @returns {Promise<Array.<string>>} A promise that resolves with a list of dependencies.
 */
async function getDependenciesForIncludedFiles(includedFiles, config) {
  let allDeps = new Set();

  for (const file of includedFiles) {
    const list = await dependencyTree.toList({
      filename: path.join(config.get.path, file),
      directory: config.get.path,
      filter: path => path.indexOf('node_modules') === -1,
      noTypeDefinitions: true
    });

    list.forEach(dep => {
      const relativePath = optimizePathForWindows(path.relative(config.get.path, dep).replace('../', ''));
      allDeps.add(relativePath);
    });
  }

  return Array.from(allDeps);
}

/**
 * Removes vendor files based on the provided configuration.
 * 
 * @async
 * @param {Object} config - The configuration object.
 * @param {Object} config.set - The target configuration.
 * @param {string} config.set.path - The path for the target.
 * @param {string} [config.set.head] - The head content to match for removal.
 * @param {Object} [config.set.removeVendors] - Configuration for removing vendors.
 * 
 * @returns {Promise<Array.<string>>} A promise that resolves with a list of removed paths.
 */
export async function removeVendors(config) {
  const files = await globby(`${config.set.path}/**/*`, config.set.removeVendors?.globby || { gitignore: true });

  let removed = [];
  for (const file of files) {
    const content = fs.readFileSync(file, 'utf8');
    if (content.startsWith(config.set.head)) {
      fs.unlinkSync(file);
      removed.push(optimizePathForWindows(file));
      let currentDir = path.dirname(file);

      while (currentDir !== config.set.path) {
        if (fs.readdirSync(currentDir).length === 0) {
          fs.rmdirSync(currentDir);
          currentDir = path.dirname(currentDir);
        } else {
          break;
        }
      }
    }
  }

  return removed;
}

/**
 * Applies file-specific transformations to relevant files in the set path.
 * 
 * @param {string} transformFolder - The folder containing file-specific transform definitions.
 * @param {string} targetPath - The base path where transformations are applied.
 */
async function applyFileTransforms(transformFolder, targetPath) {
  const transformFiles = await globby(`${transformFolder}/**/*.js`, { gitignore: true });

  for (const file of transformFiles) {
    const transformation = await import(path.resolve(file).toString());

    const strippedPath = file
      .split(transformFolder)[1]
      .slice(0, -3); // remove '.js';

    const relevantFilePath = path.join(targetPath, strippedPath);

    if (fs.existsSync(relevantFilePath)) {
      let content = fs.readFileSync(relevantFilePath, 'utf8');
      content = transformation.transform(content);
      fs.writeFileSync(relevantFilePath, content);
    }
  }
}

/**
 * Applies global transformations to all files in the set path.
 * 
 * @param {string} globalTransformFolder - The folder containing global transform definitions.
 * @param {string} targetPath - The base path where transformations are applied.
 */
async function applyGlobalTransforms(globalTransformFolder, targetPath) {
  const transforms = await globby(`${globalTransformFolder}/**/*.js`, { gitignore: true });

  for (const file of transforms) {
    const transformation = await import(path.resolve(file).toString());

    const allTargetFiles = await globby(`${targetPath}/**/*`, { gitignore: true });

    for (const targetFile of allTargetFiles) {
      let content = fs.readFileSync(targetFile, 'utf8');
      content = transformation.transform(content);
      fs.writeFileSync(targetFile, content);
    }
  }
}

/**
 * Creates vendors based on the provided configuration.
 * 
 * @async
 * @param {Object} config - The configuration object.
 * @param {Object} config.get - The source configuration.
 * @param {Object} config.set - The target configuration.
 * 
 * @returns {Promise<Array.<string>>} A promise that resolves with a list of transformed paths.
 */
export async function createVendors(config) {
  const includedFiles = await globby(config.set.includes, { cwd: config.get.path });
  const dependencies = !config.set.excludeDependencies
    ? await getDependenciesForIncludedFiles(includedFiles, config)
    : [];

  const files = [...new Set([...includedFiles, ...dependencies])];

  let transformed = [];
  for (const file of files) {
    const getPath = path.join(config.get.path, file);
    let setPath = path.join(config.set.path, file);

    let content = fs.readFileSync(getPath, 'utf8');

    // Apply any transformations from the array first
    if (config.set.transforms && Array.isArray(config.set.transforms)) {
      for (const transform of config.set.transforms) {
        const transformedFile = transform(setPath, content);

        if (transformedFile && transformedFile.path && transformedFile.content) {
          content = transformedFile.content;
          setPath = transformedFile.path;
        }
      }
    }

    if (fs.existsSync(setPath)) {
      continue;
    }

    const contentWithHead = config.set.head + "\n" + content;

    fs.mkdirSync(path.dirname(setPath), { recursive: true });
    fs.writeFileSync(setPath, contentWithHead, 'utf8');

    transformed.push(optimizePathForWindows(setPath));
  }
  return transformed;
}

/**
 * Sets up the target based on the provided configuration.
 * 
 * @async
 * @param {Object} config - The configuration object.
 * 
 * @returns {Promise<{removedFiles: string[], newFiles: string[]}>}
 */
export async function set(config) {
  const output = {};
  if (config.set.hooks?.before) {
    await execSync(config.set.hooks.before, { stdio: 'inherit' });
  }

  if (!config.set.head) {
    config.set.head = defaults.head;
  }

  if (config.set?.path) {
    output.removedFiles = await removeVendors(config);
    output.newFiles = await createVendors(config);

    // Apply global transforms
    if (config.set.globalTransformFolder) {
      await applyGlobalTransforms(config.set.globalTransformFolder, config.set.path);
    }

    // Apply file-specific transforms
    if (config.set.fileTransformFolder) {
      await applyFileTransforms(config.set.fileTransformFolder, config.set.path);
    }
  }

  if (config.set.hooks?.after) {
    await execSync(config.set.hooks.after, { stdio: 'inherit' });
  }

  return output;
}
